<hr style="border: 10px solid green;">

# 1. `Binary Search to find X in sorted array`

```java
// Input
int[] nums = {-1,0,3,5,9,12};
int target = 9;

// OUTPUT
4

// Explanation
9 exists in nums and its index is 4
```

```java
public int search(int[] nums, int target) {
    int low = 0, high = nums.length - 1;
    
    while(low <= high) {
        int mid = (low + high) / 2;
        
        if(nums[mid] == target) return mid;
        else if(nums[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

<hr style="border: 10px solid green;">

# 2. `Lower Bound`

### `Definition 1`:
Smallest index (idx) such as arr[idx] >= target
### `Definition 2`: 
Smallest index at which a specified target value can be found in a sorted array. If the target value does not exist in the array, the lower bound is the index where the target could be inserted to maintain the sorted order.

```java
int[] arr = {1, 8, 8, 8, 8, 8, 8, 10, 10, 11};
int target = 8;  // OUTPUT: 1
int target = 9;  // OUTPUT: 7
int target = 12; // OUTPUT: 10
int target = 1;  // OUTPUT: 0
int target = -9; // OUTPUT: 0
```

```java
static int lowerBound (int[] nums, int target) {
    int low = 0, high = nums.length - 1;
    
    while (low <= high) {
        int mid = (low+high)/2;
        
        if (nums[mid] >= target) high = mid - 1;
        else low = mid + 1;
    }
    
    return low;
}
```

<hr style="border: 10px solid green;">

# 3. `Upper Bound`

### `Definition 1`:
Smallest index such as arr[idx] > target
### `Definition 2`: 
Smallest index at which a specified target value can be found in a sorted array. If the target value does not exist in the array, the lower bound is the index where the target could be inserted to maintain the sorted order.

```java
// Input
int[] arr = {1, 2, 3, 4, 5, 8, 8, 10, 10, 11};
int target = 5;  // OUTPUT: 5
int target = 9;  // OUTPUT: 7
int target = 12; // OUTPUT: 10
int target = 0;  // OUTPUT: 0
int target = 1;  // OUTPUT: 1
```

```java
static int upperBound (int[] nums, int target) {
    int low = 0, high = nums.length - 1;

    while (low <= high) {
        int mid = (low+high)/2;
        
        if (nums[mid] <= target) low = mid + 1;
        else high = mid - 1;
    }
    
    return low;
}
```

<hr style="border: 10px solid green;">

# 4. `Search Insert Position`

## `Question`:
```markdown
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.
```

```java
// Input
int[] arr = {1,3,5,6];
int target = 5; // OUTPUT: 2
int target = 2; // OUTPUT: 1
int target = 7; // OUTPUT: 4
```
## `Solution`:
Just write the exact `LOWER-BOUND` code

<hr style="border: 10px solid green;">

# 5. `Floor/Ceil in Sorted Array`

**`Floor`**: largest number in the arr that is equal to or just smaller than the target.

**`Ceil`**: Smallest number in the arr that is equal to or just greater than the target AKA `LOWER-BOUND`

```java
// Input
int[] arr = {10, 20, 30, 40};
int target = 20; // OUTPUT: Floor: 20 & Ceil: 20
int target = 25; // OUTPUT: Floor: 20 & Ceil: 30
```

```java
public static int[] getFloorAndCeil(int[] a, int n, int x) {
    // floor: a[idx] <= target: largest number in the arr that is equal to or just smaller than the target
    // Ceil: a[idx] >= target: Smallest number in the arr that is equal to or just greater than the target
    int[] ans  = new int[2];
    ans[0] = -1; // floor 
    ans[1] = -1; // ceil 
    int low = 0, high = n-1;

    while (low <= high) {
    int mid=(low+high)/2;

    if (a[mid] == x) {
        ans[0] = a[mid];
        ans[1] = a[mid];
        return ans;
    } else if (a[mid] > x) {
        ans[1] = a[mid];
        high = mid - 1;
    } else {
        ans[0] = a[mid];
        low = mid + 1;
    }
    }
    return ans;
}
```

<hr style="border: 10px solid green;">

